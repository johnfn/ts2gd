import ts from "typescript"
import {
  ParseNodeType,
  parseNodeWithoutComments,
  ParseState,
} from "../parse_node"
import { Test } from "../tests/test"

const countNewlinesBeforePosition = (text: string, pos: number) => {
  let count = 0

  for (let i = pos - 1; i >= 0; i--) {
    const char = text.charAt(i)
    if (char === "\t" || char === " ") {
      continue
    }

    if (char === "\n") {
      count++
      continue
    }

    break
  }

  return count
}

export const parseComments = (
  node: ts.Node,
  props: ParseState
): ParseNodeType => {
  if (ts.isSourceFile(node)) {
    return parseNodeWithoutComments(node, props)
  }

  // gather up all leading and trailing comments from a node
  let leadingComments =
    ts
      .getLeadingCommentRanges(
        node.getSourceFile().getFullText(),
        node.getFullStart()
      )
      ?.filter((v) => v.kind === ts.SyntaxKind.SingleLineCommentTrivia) ?? []

  let trailingComments =
    ts
      .getTrailingCommentRanges(
        node.getSourceFile().getFullText(),
        node.getFullStart() + node.getFullWidth()
      )
      ?.filter((v) => v.kind === ts.SyntaxKind.SingleLineCommentTrivia) ?? []

  let lengthBeforeParsingThisNode = props.commentsStack?.length ?? 0

  if (leadingComments.length > 0 || trailingComments.length > 0) {
    if (!props.commentsStack) {
      props.commentsStack = []
    }

    /* all nodes in the same line report the same comments
       we need to take only first of the node into account and 
       ignore the rest

       example code returning the same commment multiple times:
           // some comment
           myFunc(1 + 2, someVar)
    */
    leadingComments = leadingComments.filter(
      (v) =>
        !props.commentsStack!.find((c) => c.pos === v.pos && c.end === v.end)
    )
    trailingComments = trailingComments.filter(
      (v) =>
        !props.commentsStack!.find((c) => c.pos === v.pos && c.end === v.end)
    )

    props.commentsStack.push(...leadingComments, ...trailingComments)
  }

  const result = parseNodeWithoutComments(node, props)

  if (leadingComments.length > 0 || trailingComments.length > 0) {
    const fullText = node.getSourceFile().getFullText()

    if (leadingComments.length > 0) {
      const leadingCommentsText = leadingComments.map(
        (v) => "#" + fullText.slice(v.pos + 2, v.end)
      )
      const addFirstNewLineToLeadingComments =
        countNewlinesBeforePosition(fullText, leadingComments[0].pos) > 1 ||
        !result.content.endsWith("\n")

      result.content =
        (addFirstNewLineToLeadingComments ? "\n" : "") +
        leadingCommentsText.join("\n") +
        "\n" +
        result.content
    }

    if (trailingComments.length > 0) {
      const trailingCommentsText = trailingComments.map(
        (v) => "#" + fullText.slice(v.pos + 2, v.end)
      )
      const addFirstNewLineToTrailingComments =
        countNewlinesBeforePosition(fullText, trailingComments[0].pos) > 0

      result.content =
        result.content +
        (addFirstNewLineToTrailingComments ? "\n" : " ") +
        trailingCommentsText.join("\n") +
        "\n"
    }

    props.commentsStack = props.commentsStack?.slice(
      0,
      lengthBeforeParsingThisNode
    )
  }

  return result
}

export const testComments: Test = {
  keepComments: true,
  ts: `
// This is a test class
// abc
class Test extends Area2D {
  // This a constructor
  constructor() {
    // This is a super call

  }

  // this is a method
  method() {
    // this is a print
    print("a")

    // This is an if statement
    if (2 == 3) {
      // This is an empty block
    }

    print(/* this is block comment */"l")

    print(
      // this is a call with parameters in multiple lines
      "hello",
      // this is second parameter
      "world"
    )

    // this is a print
    // this is a print
    // and this is third comment
    print("b")

    print("x") // leading comment
  }
}
    `,
  expected: `
# This file has been autogenerated by ts2gd. DO NOT EDIT!
extends Area2D
class_name Test
# This is a test class
# abc
# This a constructor
func _ready():
  pass
# this is a method
func method():
  # this is a print
  print("a")
  # This is an if statement
  if ((typeof(2) == typeof(3)) and (2 == 3)):
    pass
  print("l")
  print(
  # this is a call with parameters in multiple lines
  "hello",
  # this is second parameter
  "world")
  # this is a print
  # this is a print
  # and this is third comment
  print("b")
  print("x") # leading comment
  `,
}
