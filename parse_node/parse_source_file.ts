import ts, { ClassDeclaration, SyntaxKind } from "typescript"

import { ErrorName, addError } from "../errors"
import { ParseNodeType, ParseState, combine, parseNode } from "../parse_node"
import { Test } from "../tests/test"
import { checkIfMainClass } from "../ts_utils"

import { LibraryFunctions } from "./library_functions"

type ParsedClassDeclaration = {
  fileName: string
  parsedClass: ParseNodeType
  classDecl: ts.ClassDeclaration | ts.ClassExpression
  isMain: boolean
}

/**
 * The class_name and extends statements *must* come first in the file, so we
 * preprocess the class to find them prior to our normal pass.
 */
const getClassDeclarationHeader = (
  node: ts.ClassDeclaration | ts.ClassExpression,
  props: ParseState
) => {
  const modifiers = (node.modifiers ?? []).map((x) => x.getText())
  // TODO: Can be moved into parse_class_declaration i think

  let extendsFrom = ""

  if (node.heritageClauses) {
    // TODO: Ensure there's only one of each here

    const clause = node.heritageClauses[0] as ts.HeritageClause
    const type = clause.types[0]
    const tsType = props.program.getTypeChecker().getTypeAtLocation(type)

    extendsFrom = type.getText()

    if (tsType.symbol && tsType.symbol.declarations) {
      // Handle the case when extended class is a inner class of file
      const classDecl = tsType.symbol.declarations.find((v) =>
        ts.isClassDeclaration(v)
      ) as ClassDeclaration | null

      if (classDecl) {
        const modifiers = (classDecl.modifiers ?? []).map((v) => v.getText())

        const asset = props.project
          .sourceFiles()
          .find((v) => v.fsPath === classDecl.getSourceFile().fileName)

        if (
          !modifiers.includes("declare") &&
          (!props.isMainClass || !classDecl.name)
        ) {
          // Only when a class is not marked as 'declare' and a class is inner
          // class (does not have 'default') or anonymous class (does not have a name)

          if (!asset) {
            extendsFrom = ""
            addError({
              description: `Class ${
                classDecl.name ?? `<${classDecl.getSourceFile().fileName}>`
              } extends ${type.getText()} for which a source file is missing. This is an internal ts2gd bug. Please report it.`,
              error: ErrorName.ClassDoesntExtendAnything,
              location: node,
              stack: new Error().stack ?? "",
            })
          } else if (!props.isMainClass) {
            // If a class declaration does not have default export then this is an inner class
            // The syntax for extending inner class in gdscript is: extends "res://compiled/Test.gd".BaseType

            if (props.sourceFileAsset === asset) {
              extendsFrom = type.getText()
            } else {
              extendsFrom = `"${asset.resPath}".${type.getText()}`
            }
          } else if (!classDecl.name) {
            // If a class declaration have default export and does not have a name then it is anonymous
            // The syntax for extending anonymous class in gdscript is: extends "res://compiled/Test.gd"

            extendsFrom = `"${asset.resPath}"`
          }
        }
      }
    }
  }

  const isTool = !!node.decorators?.find(
    (dec) => dec.expression.getText() === "tool"
  )

  if (props.isMainClass) {
    return `${isTool ? "tool\n" : ""}${
      extendsFrom ? `extends ${extendsFrom}` : ""
    }
${props.isAutoload || !node.name ? "" : `class_name ${node.name.getText()}\n`}`
  }

  if (isTool) {
    addError({
      description: `
Only the main class can be decorated as tool. You can make this the main class either by exporting it as default, or using @main. For example:

@tool export default class ${node.name?.getText() ?? ""} { // ...

Or:

@tool @main export class ${node.name?.getText() ?? ""} { // ...
`,
      error: ErrorName.ClassMustBeExported,
      location: node,
      stack: new Error().stack ?? "",
    })
  }

  return `
class ${node.name?.getText()}${extendsFrom ? ` extends ${extendsFrom}` : ""}:`
}

export const getFileHeader = (): string => {
  return `# This file has been autogenerated by ts2gd. DO NOT EDIT!\n\n`
}

export const parseSourceFile = (
  node: ts.SourceFile,
  props: ParseState
): ParseNodeType => {
  const { statements } = node
  const sourceInfo = props.project
    .sourceFiles()
    .find((file) => file.fsPath === node.fileName)

  // props.usages = utils.collectVariableUsage(node)
  props.isAutoload = sourceInfo?.isAutoload() ?? false

  const parsedClassDeclarations: ParsedClassDeclaration[] = []
  let hoistedLibraryFunctionDefinitions = ""
  let hoistedEnumImports = ""
  let hoistedArrowFunctions = ""

  /**
   * These are almost always an error - it's invalid to write let x = 5 outside of
   * a method scope in ts2gd. However, we use them for two reasons.
   *
   * 1. They make test writing a heck of a lot more convenient - no need to wrap
   * everything in a class
   * 2. They are used to declare the autoload global variable.
   */
  let toplevelStatements: ts.Statement[] = []

  const files: { filePath: string; body: string }[] = []

  for (const statement of statements) {
    if (
      statement.kind !== SyntaxKind.ClassDeclaration &&
      statement.kind !== SyntaxKind.ClassExpression
    ) {
      toplevelStatements.push(statement)

      continue
    }

    props.isMainClass = checkIfMainClass(statement as ts.ClassDeclaration)

    const parsedStatement = parseNode(statement, props)

    if (!statement.modifiers?.map((m) => m.getText()).includes("declare")) {
      // TODO: Push this logic into class declaration and expression classes

      const classDecl = statement as ts.ClassDeclaration | ts.ClassExpression
      const className = classDecl.name?.text

      parsedClassDeclarations.push({
        fileName:
          props.sourceFileAsset.gdContainingDirectory + className + ".gd",
        parsedClass: parsedStatement,
        classDecl,
        isMain: props.isMainClass,
      })
    }

    for (const lf of parsedStatement.hoistedLibraryFunctions ?? []) {
      hoistedLibraryFunctionDefinitions +=
        LibraryFunctions[lf].definition("__" + LibraryFunctions[lf].name) + "\n"
    }

    for (const af of parsedStatement.hoistedArrowFunctions ?? []) {
      hoistedArrowFunctions += af.content + "\n"
    }

    for (const fi of parsedStatement.files ?? []) {
      files.push(fi)
    }
  }

  const codegenToplevelStatements =
    toplevelStatements.length > 0
      ? combine({
          nodes: toplevelStatements,
          parent: toplevelStatements[0].parent,
          props,
          parsedStrings: (...strs) => strs.join("\n"),
        })
      : undefined

  for (const lf of codegenToplevelStatements?.hoistedLibraryFunctions ?? []) {
    hoistedLibraryFunctionDefinitions +=
      LibraryFunctions[lf].definition("__" + LibraryFunctions[lf].name) + "\n"
  }

  for (const af of codegenToplevelStatements?.hoistedArrowFunctions ?? []) {
    hoistedArrowFunctions += af.content + "\n"
  }

  for (const fi of codegenToplevelStatements?.files ?? []) {
    files.push(fi)
  }

  let classFile: {
    mainClass: ParsedClassDeclaration | null
    innerClasses: ParsedClassDeclaration[]
  } = {
    mainClass: null,
    innerClasses: [],
  }

  for (const cls of parsedClassDeclarations) {
    if (cls.isMain) {
      classFile.mainClass = cls
    } else {
      classFile.innerClasses.push(cls)
    }
  }

  if (
    !classFile.mainClass &&
    // check if all inner classes are not marked explicitly @inner
    !classFile.innerClasses.every((v) =>
      (v.classDecl.decorators ?? [])
        .map((d) => d.expression.getText())
        .includes("inner")
    )
  ) {
    addError({
      description: `Please mark one of ${classFile.innerClasses
        .map((v) => v.classDecl.name?.getText())
        .join(
          ", "
        )} as the main class using 'export default' or '@main' decorator. For example:

export default class ${
        classFile.innerClasses[0].classDecl.name?.getText() ?? ""
      } { // ...

Or:

@main export class ${
        classFile.innerClasses[0].classDecl.name?.getText() ?? ""
      } { // ...
`,
      error: ErrorName.TooManyClassesFound,
      location: node,
      stack: new Error().stack ?? "",
    })
  }

  let fileBody = `${getFileHeader()}\n`

  if (classFile.mainClass) {
    if (
      !(classFile.mainClass.classDecl.modifiers ?? [])
        .map((v) => v.getText())
        .includes("export")
    ) {
      addError({
        description: `Main class ${
          classFile.mainClass.classDecl.name?.getText() ?? "<anonymous>"
        } must be exported. For example:

export default class ${
          classFile.mainClass.classDecl.name?.getText() ?? ""
        } { // ...
`,
        error: ErrorName.ClassMustBeExported,
        location: node,
        stack: new Error().stack ?? "",
      })
    } else {
      props.isMainClass = true
      fileBody += `${getClassDeclarationHeader(
        classFile.mainClass.classDecl,
        props
      )}\n`
    }
  }

  props.isMainClass = false
  fileBody += `
${hoistedEnumImports}
${hoistedLibraryFunctionDefinitions}
${hoistedArrowFunctions}
${codegenToplevelStatements?.content ?? ""}
${classFile.innerClasses
  .map(
    (innerClass) => `
${getClassDeclarationHeader(innerClass.classDecl, props)}
${
  innerClass.parsedClass.content.trim()
    ? innerClass.parsedClass.content
        .trim()
        .split("\n")
        .map((line) => "  " + line)
        .join("\n")
    : "  pass"
}
`
  )
  .join("\n")}
`

  if (classFile.mainClass) {
    fileBody += `${classFile.mainClass.parsedClass.content}\n`
  }

  files.push({
    filePath: props.sourceFileAsset.gdPath,
    body: fileBody,
  })

  return {
    files,
    content: "",
  }
}

export const testToolAnnotation: Test = {
  ts: `
@tool
export default class Test {
}
  `,
  expected: `
tool
class_name Test
`,
}

export const testInnerClass: Test = {
  ts: `
@inner
export class InnerTest {
  field: int = 2;
}
  `,
  expected: `
class InnerTest:
  var field: int = 2
`,
}

export const testAnonymousClass: Test = {
  ts: `
export default class extends Node2D {
}
  `,
  expected: `
extends Node2D
`,
}
